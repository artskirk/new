<?php

namespace Datto\Malware;

use Datto\Asset\Agent\AgentService;
use Datto\Asset\Agent\Agent;
use Datto\Asset\Agent\DattoImage;
use Datto\Asset\Asset;
use Datto\Asset\AssetType;
use Datto\Asset\RansomwareResults;
use Datto\Common\Resource\ProcessFactory;
use Datto\Log\LoggerAwareTrait;
use Datto\Common\Utility\Filesystem;
use Datto\Restore\AssetCloneManager;
use Exception;
use PDO;
use Psr\Log\LoggerAwareInterface;
use Throwable;

/**
 * Class: RansomwareService handles detection of Ransomware
 *
 * @author Jeffrey Knapp <jknapp@datto.com>
 * @author Matthew Cheman <mcheman@datto.com>
 * @author Chuck Roydhouse <cer@datto.com>
 */
class RansomwareService implements LoggerAwareInterface
{
    use LoggerAwareTrait;

    const HORUS_FILE_PATH = "/dev/shm/ransomware/horus-%s-%d-%s.sqlite";

    const HORUS_PROCESS_TIMEOUT_IN_SECONDS = 300;
    const HORUS_BINARY = '/usr/bin/horus';
    const HORUS_READ_SIZE = 4096;

    const FOUND_LOG_CODE = 'MAL0001';
    const FOUND_LOG_MESSAGE = self::FOUND_LOG_CODE . ' This agent has been identified as having signs of ransomware.';

    const ONLY_WINDOWS_EXCEPTION_MESSAGE = 'Only Windows systems can be checked for ransomware.';
    const DISABLED_RANSOMWARE_EXCEPTION_MESSAGE = 'This agent has disabled ransomware checks.';

    const SUPPORTED_ASSET_TYPES = [AssetType::WINDOWS_AGENT, AssetType::AGENTLESS_WINDOWS];

    const MKDIR_MODE = 0777;

    private ProcessFactory $processFactory;
    private AgentService $agentService;
    private AssetCloneManager $cloneManager;
    private Filesystem $filesystem;

    public function __construct(
        ProcessFactory $processFactory,
        AgentService $agentService,
        AssetCloneManager $cloneManager,
        Filesystem $filesystem
    ) {
        $this->processFactory = $processFactory;
        $this->agentService = $agentService;
        $this->cloneManager = $cloneManager;
        $this->filesystem = $filesystem;
    }

    /**
     * Runs a suite of ransomware tests and returns the results.
     *
     * @param Agent $agent
     * @param DattoImage[] $dattoImages
     * @param int $snapshotEpoch
     * @param int|null $currentTime Optional parameter to inject the current time dependency
     * @param PDO|null $pdo Optional paramater to inject the pdo dependency
     * @param RansomwareDetection $ransomwareDetection Optional paramater to inject the ransomware detection dependency
     * @return RansomwareResults the aggregate of test results
     */
    public function runTests(
        Agent $agent,
        array $dattoImages,
        int $snapshotEpoch,
        ?int $currentTime = null,
        PDO $pdo = null,
        RansomwareDetection $ransomwareDetection = null
    ): RansomwareResults {
        $this->logger->setAssetContext($agent->getKeyName());

        if ($currentTime === null) {
            $currentTime = time();
        }

        $this->logger->info('MAL0025 Starting ransomware check on snapshot', ['snapshot' => $snapshotEpoch]);

        $hasRansomware = false;
        $exception = null;
        $horusFile = null;

        try {
            if (!$this->isTestable($agent)) {
                throw new Exception(static::ONLY_WINDOWS_EXCEPTION_MESSAGE);
            }
            if (!$agent->getLocal()->isRansomwareCheckEnabled()) {
                throw new Exception(static::DISABLED_RANSOMWARE_EXCEPTION_MESSAGE);
            }

            $this->logger->debug('MAL0018 Cleaning up old clones');
            // Added for CP-12633 - Before local verification stages shared a clone, ransomware created its own.
            // Clean up orphaned clones still left around by the old code here.
            $this->cloneManager->cleanOrphanedClones($agent->getKeyName(), 'ransomware');

            $this->logger->info('MAL0004 Running ransomware check on snapshot', ['snapshot' => $snapshotEpoch]);

            $osVolume = $this->getOsImage($dattoImages);

            $horusFile = sprintf(
                static::HORUS_FILE_PATH,
                $agent->getKeyName(),
                $snapshotEpoch,
                $osVolume->getVolume()->getGuid()
            );
            $this->filesystem->mkdirIfNotExists(dirname($horusFile), false, self::MKDIR_MODE);

            $this->runHorus($osVolume->getPathToPartition(), $horusFile);

            $horusPdo = $pdo ?: new PDO('sqlite:' . $horusFile);
            $ransomwareDetection = $ransomwareDetection ?: new RansomwareDetection($horusPdo);

            $results = $ransomwareDetection->detect();
            $hasRansomware = (bool) $results['hasRansomware'];

            $this->logMetrics($results);
        } catch (Throwable $throwable) {
            $this->logger->error('MAL0020 An error occurred while running the ransomware tests.', ['exception' => $throwable]);
            $exception = $throwable;
        } finally {
            if ($this->filesystem->exists($horusFile ?? '')) {
                $this->filesystem->unlink($horusFile);
            }
        }

        $this->logger->info('MAL0011 Done running ransomware tests; compiling results.');

        $hasAlertsSuspended = $agent->getLocal()->getRansomwareSuspensionEndTime() >= $currentTime;

        $ransomwareResults = new RansomwareResults(
            $agent->getKeyName(),
            $snapshotEpoch,
            $hasRansomware,
            $exception !== null,
            $exception ? get_class($exception) : null,
            $exception ? $exception->getMessage() : null,
            $hasAlertsSuspended,
            $agent->getOperatingSystem()->getName()
        );

        $this->doEventLogging($ransomwareResults, $hasAlertsSuspended);
        $this->updateRecoveryPoints($agent, $ransomwareResults);

        return $ransomwareResults;
    }

    /**
     * Checks whether the asset can be tested for ransomware
     *
     * @param Asset $asset
     * @return bool true if the asset can be tested, false otherwise
     */
    public function isTestable(Asset $asset): bool
    {
        if (!$this->agentService->exists($asset->getKeyName())) {
            return false;
        } else {
            return in_array($asset->getType(), static::SUPPORTED_ASSET_TYPES);
        }
    }

    /**
     * Determine which volume is the OS drive.
     *
     * @param DattoImage[] $volumeImages
     * @return DattoImage
     */
    private function getOsImage(array $volumeImages): DattoImage
    {
        foreach ($volumeImages as $image) {
            if ($image->getVolume()->isOsVolume()) {
                return $image;
            }
        }

        throw new Exception('Agent has no OS volume');
    }

    /**
     * Log the ransomware results to the ELK stack.
     *
     * @param RansomwareResults $ransomwareResults
     * @param boolean $suspendAlerts whether or not alerts are suspsended
     */
    private function doEventLogging(
        RansomwareResults $ransomwareResults,
        bool $suspendAlerts
    ): void {
        if ($ransomwareResults->hasRansomware()) {
            if ($suspendAlerts) {
                $this->logger->warning('MAL0019 This agent has been identified as having signs of ransomware, but alerting has been suspended.');
            } else {
                $this->logger->warning(static::FOUND_LOG_MESSAGE); // nosemgrep: utils.security.semgrep.log-context-in-message, utils.security.semgrep.log-no-log-code
            }
        } elseif ($ransomwareResults->hasException()) {
            $this->logger->warning('MAL0002 Ransomware detection resulted in an exception', ['error' => $ransomwareResults->getExceptionMessage()]);
        } else {
            $this->logger->info('MAL0003 No ransomware found.');
        }
    }

    /**
     * Update the Agent's recovery points with the given ransomware results.
     *
     * @param Agent $agent
     * @param RansomwareResults $ransomwareResults
     */
    private function updateRecoveryPoints(
        Agent $agent,
        RansomwareResults $ransomwareResults
    ): void {
        if (!$ransomwareResults->hasException()) {
            $recoveryPoints = $agent->getLocal()->getRecoveryPoints();
            $recoveryPoint = $recoveryPoints->get($ransomwareResults->getSnapshotEpoch());
            $recoveryPoint->setRansomwareResults($ransomwareResults);
            $this->agentService->save($agent);
        }
    }

    private function runHorus(string $partition, string $horusFile): void
    {
        $this->logger->debug('MAL0012 Creating horus process.');
        $process = $this->processFactory
            ->get([
                static::HORUS_BINARY,
                '-f', 'sqlite:' . $horusFile,
                '-r', static::HORUS_READ_SIZE,
                '-t', static::HORUS_PROCESS_TIMEOUT_IN_SECONDS,
                $partition
            ])
            ->setTimeout(static::HORUS_PROCESS_TIMEOUT_IN_SECONDS + 10);

        $this->logger->debug('MAL0013 Running horus process');
        $process->mustRun();
    }

    private function logMetrics(array $results): void
    {
        /** @var RansomwareRule $rule */
        foreach ($results['rules'] as $rule) {
            $name = $rule->getName();
            $detected = $rule->getResult();
            $occurrences = $rule->getOccurrences();
            $total = $rule->getTotal();
            $percent = (int) $rule->getPercent() * 100;

            $message = "$occurrences out of $total files checked showed signs of ransomware ($percent%%).";
            if ($detected) {
                $this->logger->warning('MAL0027 Ransomware Rule detected ransomware.', ['ruleName' => $name, 'error' => $message]);
            } else {
                $this->logger->info('MAL0026 Ransomware Rule did not detect ransomware.', ['ruleName' => $name, 'error' => $message]);
            }
            $this->logger->info('MAL0028 Ransomware metrics collected.', ['metrics' => json_encode($rule->toArray())]);
        }
    }
}
